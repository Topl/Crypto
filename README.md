# Prosomo

Ouroboros Prosomoiotís (v0.2)
Aaron Schutza
June 2019


- Introduction / purpose
- Requirements
    - Capabilities
    - Constraints
- Specification
- Rationale


Purpose

A simulation of the Ouroboros Proof of Stake protocol has been written.  Prosomoiotís - the Greek word for simulator, is a stand alone blockchain application that executes the Ouroboros protocol.  We intend to study the properties of the protocol and probe the behavior of the emulated network under different parameterizations of the model.  Key parameters include the active slots coefficient, epoch length, network delay, active party number, stake distribution, and confirmation depth.  The simulation is designed to mimic the real world execution of the protocol in a single network node, thus all security and cryptographic measures are carried out by the actors.  In principle the simulation could be extended to communicate with other nodes over a network to achieve the same consensus, persistence, and liveness properties that the protocol guarantees.  For now, the scope is limited to instantiating a set of actors on one node that communicate via message passing.  The number of actors is limited only by the memory of the node and simulations using hundreds of actors are possible, spanning thousands of epochs.

Requirements
Capabilities
- Uses Akka actors to emulate stakeholders
- One coordinator actor instantiates the stakeholders, collects their public keys, and disseminates the genesis block
- The coordinator acts as a global clock from which all stakeholders get the current time
- Stakeholders communicate via Akka message passing
- Forged blocks give stakeholders a forger reward that adds to their stake distribution
- Transactions are issued, broadcast, and added to forged blocks
Constraints
- Designed to emulate Ouroboros Genesis - the actors should mimic the dynamic stake protocol given in Praos and Genesis as closely as possible
- The execution should be resilient against adversarial tampering assuming honest majority
- Actors should reach consensus
- Should achieve a robust live ledger
Specification

The target protocol is Ouroboros Genesis and some terminology and functionality will carry over from Ouroboros Praos.  The main difference between the two is the chain selection rule.  Stakeholders participate in rounds by diffusing messages and registering the other parties present on the network.  The stake distribution and epoch nonce is set at the beginning of each epoch.  The epoch nonce represents the seed randomness for which all stakeholders apply their Verifiable Random Function for slot leader election and future nonce generation.  The threshold of slot leader eligibility during the epoch is held constant and updated each epoch from the chain generated in two previous epochs.  The stakeholders proceed round by round communicating forged blocks and transactions that are issued from stakeholders.

The most up to date specification is given in the February 2019 edit of Genesis:

https://www.dropbox.com/s/5z7h4gyijjn0xys/Genesis.pdf?dl=0


Execution of the simulated protocol will constitute a robust test of established cryptographic primitives designed for use with the protocol.  The three discrete functionalities currently used by the actors are the Digital Signature (DS), Key Evolving Signature (KES), and Verifiable Random Function (VRF) ideal functionalities specified for Praos and Genesis.  A global clock is represented with the system clock to keep the actors in sync and the coordinator actor gives each stakeholder this system time passed through a message.  This acts as a stand in for the global clock functionality used to specify Genesis.  The hash function used is the Blake2b FashCryptographicHash function given in Scorex.  The DS functionality is used for transaction verification and party identification and is currently the Scorex Curve25519 signing routine.  The VRF is used for slot leader election and epoch nonce generation and is the Ed25519 VRF.  The KES functionality is used for block signing and verification, constructed using the Malkin-Micciancio-Miner (MMM) construction.

Nonces are generated by the concatenation of VRF outputs from the first 2/3 of the previous epoch along with the previous nonce.  A separate VRF output is compared to a threshold set by the staking party.  The VRF acts as a pseudorandom number generator for nonce generation. A separate test value of VRF is compared agains the epoch staking threshold to determine slot leader eligibility.  The test VRF outputs that are committed to the chain will preferentially have leading zeroes so that’s why a separate VRF is used for nonce generation.  All actors keep a view of local state from which the stake distribution and epoch threshold can be calculated for block validation.  Every single block must be validated against the stake distribution so all parties with any amount of stake have to have an entry in local state.  In a given epoch, the relative stake for block validation and leader election is sampled from the stake distribution from two epochs prior.

In this simulation, the state of each stakeholder is represented as an integer value balance along with a transaction counter and activity flag.  If the stake is active, the activity flag is true and the balance contributes the the net stake of the system.  The transaction counter enforces the ordering of transactions issued by stakeholders and prevents double counting state transitions when blocks are applied to state.  Currently all stake is considered active so the activity flag is always true.

Chain selection occurs in accordance with maxvalid-bg specified in Ouroboros Genesis.  This selects a chain based on longest chain rule when the common ancestor is above a specified depth.  When the common ancestor is below that depth, the stakeholder will select the densest tine within a window of slots after the prefix slot.

An example output of the protocol is given below:


    Populating
    Sending holders list
    Sending holders coordinator ref
    Getting holder keys
    Forge Genesis Block
    Send GenBlock
    Starting
    Diffuse Holder Info
    Run
    Holder 0 starting...
    Holder 1 starting...
    Holder 2 starting...
    Holder 3 starting...
    Holder 4 starting...
    Holder 5 starting...
    Holder 6 starting...
    Holder 7 starting...
    Holder 0 Issued Transaction
    Slot = 1
    Current Epoch = 0
    Holder 0 alpha = 0.2564635112943776
    Eta:f107bda4b3f76a926388449dfe980a7a9e0e659895129517ac8f011db6839752
    Holder 0 Update KES
    Holder 0 ForgeBlocks
    Holder 0 Received Block
    Holder 0 Update Chain
    Holder 0 Adopting Tine
    Slot = 1
    Holder 0 ForgeBlocks
    Slot = 2
    Holder 0 Update KES
    Holder 0 ForgeBlocks
    Holder 0 Received Block
    Holder 0 Update Chain
    Holder 0 Adopting Tine
    Slot = 2
    Holder 0 ForgeBlocks
    Slot = 3
    Holder 0 Update KES
    Holder 0 ForgeBlocks
    Holder 0 is slot a leader
    Holder 0 Issued Transaction
    Slot = 4
    Holder 0 Update KES
    Holder 0 ForgeBlocks
    Slot = 5
    Holder 0 Update KES
    Holder 0 ForgeBlocks
    Holder 0 is slot a leader
    Holder 0 Received Block
    Holder 0 Received Block
    Holder 0 Update Chain
    Holder 0 Update Chain
    Slot = 6
    Holder 0 Update KES
    Holder 0 ForgeBlocks
    Holder 0 is slot a leader
    Holder 0 Received Block
    Holder 0 Update Chain
    Slot = 7
    Holder 0 Update KES
    Holder 0 ForgeBlocks
    Slot = 8
    Holder 0 Update KES
    Holder 0 ForgeBlocks
    Holder 0 Issued Transaction
    Slot = 9
    Holder 0 Update KES
    Holder 0 ForgeBlocks
    Holder 0 Received Block
    Holder 0 Received Block
    Holder 0 Update Chain
    Holder 0 Adopting Tine
    Slot = 9
    Holder 0 Update Chain
    -----------------------------------------------------------
    -----------------------------------------------------------
    Holder 0: t = 9, alpha = 0.2564635112943776, blocks forged = 3
    Chain length = 7, Valid chain = true
    Chain hash: 73b07459c10586bb51c8be299fd00643645c79637c2980b50c9a3420adfded80
    
    Holder 1: t = 9, alpha = 0.21539364569240807, blocks forged = 3
    Chain length = 7, Valid chain = true
    Chain hash: 73b07459c10586bb51c8be299fd00643645c79637c2980b50c9a3420adfded80
    
    Holder 2: t = 9, alpha = 0.01964278084533613, blocks forged = 0
    Chain length = 7, Valid chain = true
    Chain hash: 73b07459c10586bb51c8be299fd00643645c79637c2980b50c9a3420adfded80
    
    Holder 3: t = 9, alpha = 0.04145919313624614, blocks forged = 0
    Chain length = 7, Valid chain = true
    Chain hash: 73b07459c10586bb51c8be299fd00643645c79637c2980b50c9a3420adfded80
    
    Holder 4: t = 9, alpha = 0.2146442877177694, blocks forged = 3
    Chain length = 7, Valid chain = true
    Chain hash: 73b07459c10586bb51c8be299fd00643645c79637c2980b50c9a3420adfded80
    
    Holder 5: t = 9, alpha = 0.1675772672476359, blocks forged = 1
    Chain length = 7, Valid chain = true
    Chain hash: 73b07459c10586bb51c8be299fd00643645c79637c2980b50c9a3420adfded80
    
    Holder 6: t = 9, alpha = 0.03670977990590448, blocks forged = 0
    Chain length = 7, Valid chain = true
    Chain hash: 73b07459c10586bb51c8be299fd00643645c79637c2980b50c9a3420adfded80
    
    Holder 7: t = 9, alpha = 0.048109534160322244, blocks forged = 0
    Chain length = 7, Valid chain = true
    Chain hash: 73b07459c10586bb51c8be299fd00643645c79637c2980b50c9a3420adfded80
    
    

The above terminal output represents a simulation of 8 actors executing the dynamic stake protocol.  All signing and verification routines are executing in the simulated protocol.  The chain is validated per the isValidChain specification in Ouroboros Genesis.  The confirmed chain hash is independently calculated by each actor.  If this hash is consistent across all actors that indicates that they have the same chain data for blocks below a confirmation depth.  The alpha value represents the actors relative stake for the current epoch.  Blocks forged represents the total number of times that the actor was elected slot leader.  The staking party is set at the beginning of each epoch so the simulation tolerates actors dynamically becoming active and inactive.

A command line script for interacting with the simulation is provided in the project directory.  To execute the command line, run Crypto/cmd.sh in a separate terminal.  This is used to pass commands to Prosomo via a file tmp/scorex/test-data/crypto/cmd and also can be used to queue commands at a later slot.  Just enter the desired slot number next to the command, e.g.:


    Enter command (q to exit) :
    split
    Enter command (q to exit) :
    pause
    Enter command (q to exit) :
    join
    Enter command (q to exit) :
    pause
    Enter command (q to exit) :
    verify
    Enter command (q to exit) :
    split 100
    Enter command (q to exit) :
    join 300
    Enter command (q to exit) :
    

Several commands are available:


    status

Prints the status of each stakeholder, including the chain hash and number of transactions in the mempool and on the chain


    verify

Prints the status of each stakeholder, including the chain hash, transaction in mempool, and verifies the chain from the genesis block


    stall

Stalls all actors except for the coordinator.  The global clock will continue to tick.


    pause

Pauses the coordinator.  The global clock will stop but all stakeholders will continue to execute until the last known slot.


    inbox

Stakeholders print their inbox which represents a list of all known parties which they are aware of and communicating with.


    stall0

Stalls the stakeholder that is first on the list and also the stakeholder that prints its activity to the terminal.  All other stakeholders continue the execution in the background.


    randtx

Turns on or off the  coordinator issuing randomized transactions.


    write

Clears the file writer buffer and writes it to disk.  Run before plotting.


    kill

Stops all execution.


    split

Splits all stakeholders into two randomly selected parties.


    bridge

Splits all stakeholders into two randomly selected parties with one stakeholder in both parties.


    join

Joins the parites back together and resets all actors gossipers


    plot

Plots the most recent data output

Plots are created with python script via matplotlib.  Some example plots for a simulation using 8 stakeholders are given below:

![The total blocks forged are in black and each color corresponds to a different stakeholders total blocks forged.  The gray line indicates the slot number and is the maximum number of possible blocks.  The slope of each line is proportional to the relative stake of each holder.](https://paper-attachments.dropbox.com/s_C53A9B5A66DD0ACE9282A605A95BC9BBCE353CF04DC1B23923A105EDD21CC07D_1564119461665_Figure_1.png)

![The relative stake of each holder represented by 8 different colors.  Each dot represents a different epoch and the stake changes between epochs.](https://paper-attachments.dropbox.com/s_C53A9B5A66DD0ACE9282A605A95BC9BBCE353CF04DC1B23923A105EDD21CC07D_1564119472814_Figure_2.png)


The main parameters of the simulation are given in /Crypto/src/main/scala/crypto/ouroboros/parameters.scala:


    //max initial stake
    val initStakeMax = 1.0e9
    
    //max random transaction delta
    val maxTransfer = 1.0e9
    
    //reward for forging blocks
    val forgerReward = 1.0e7
    
    //percent of transaction amount taken as fee by the forger
    val transferFee = 0.01
    
    //active slot coefficient, 'difficulty parameter' (0 < f_s < 1)
    val f_s = 0.9
    
    // checkpoint depth in slots, k parameter in maxValid-bg
    val k_s:Int = 30
    
    // epoch length R >= 3k/2f
    val epochLength:Int = 3*(k_s*(0.5/f_s)).toInt
    
    // slot window for chain selection, s = k/4f
    val slotWindow:Int = (k_s*0.25/f_s).toInt
    
    //status and verify check chain hash data up to this depth to gauge consensus amongst actors
    val confirmationDepth = 10
    
    //number of holders on gossip list for sending new blocks and transactions
    val numGossipers = 6
    
    //max number of tries for a tine to ask for parent blocks
    val tineMaxTries = 10
    
    //max depth in multiples of confirmation depth that can be returned from an actor
    val tineMaxDepth = 10
    
    //data write interval in slots
    val dataOutInterval = epochLength
    
    //duration of slot in milliseconds
    val slotT:Long = 200
    
    //time out for dropped messages from coordinator
    val waitTime = 600 seconds
    
    //duration between update tics that stakeholder actors send to themselves
    val updateTime = 1.millis
    
    //duration between command read tics and transaction generation for the coordinator
    val commandUpdateTime = (slotT/2).toInt.millis
    
    //Issue random transactions if true
    var transactionFlag = true
    
    //uses randomness for public key seed and initial stake, set to false for deterministic run
    val randomFlag = true
    
    //when true, if system cpu load is too high the coordinator will stall to allow stakeholders to catch up
    val performanceFlag = true
    
    //threshold of cpu usage above which coordinator will stall if performanceFlag = true
    val systemLoadThreshold = 0.95
    
    //number of values to average for load threshold
    val numAverageLoad = 3
    
    //print Stakeholder 0 status per slot if true
    val printFlag = true
    
    //print Stakeholder 0 execution time per slot if true
    val timingFlag = false
    
    //Record data if true, plot data points with ./cmd.sh and enter command: plot
    val dataOutFlag = true

Each actor executes in its own thread so they compete for computational resources.  This constrains the time step, represented by the slot time length, to scale with the resource load of all actors.  Slot times of as little as 50 ms are possible with 32 actors without a transaction load.  With a randomized transaction load of ~100 per slot, 64 actors can execute the protocol with 1 second slot times on desktop hardware.  Pushing the slot time lower causes actors to lag the coordinator clock.  A performance limiting feature has been built in to stall the coordinator when the system load reaches a threshold.  This slows the time between slots, allowing the holder actors to complete execution of protocol routines before the next slot commands are issued.  This allows massive reorgs with hundreds of actors to play out without the coordinator racing ahead.

Rationale

Ouroboros has been presented in a very rigorous and formal mathematical style that stands out among other protocol designs. The protocol is formulated from probabilistic arguments drawn from mathematical proofs about the outcome of an idealized representation constructed from ideal functionalities.  This presentation style gives assurance that the protocol is secure but makes it difficult to conceptualize the procedure and how it operates on a network.  We wish to form a better intuition about protocol behavior under different circumstances to put theory to the test.  The papers provide no data about the execution of the protocol and details of the actual implementation are sparse at best.   We will remedy this by plotting metrics of the simulated network for different settings of key parameters.  Future work involves simulating adversarial manipulation, network connectivity conditions, and chain visualization.